// https://github.com/Blockchain-Bites/two-party-computation-signature.git
// File: 6-Two-Party-Signing/1-TwoPartySigning.js
// Test: node 6-Two-Party-Signing/1-TwoPartySigning.js

var crypto = require("crypto");

var {
  ECC,
  Point,
  combineInstancesInto,
} = require("../0-EllipticCurve/EllipticCurve");
var {
  Paillier,
} = require("../3-Paillier-Encryption/1-paillierEncryptionSolution");

// Elliptic curve parameters
const q = 10133n; // Order of the curve (number of points)
const a = 9158n; // Coefficient 'a' in the Weierstrass equation
const b = 7614n; // Coefficient 'b' in the Weierstrass equation
const G = new Point(3779n, 1910n); // Generator point
const p = 9967n; // Prime modulus (field size)

// Initialize cryptographic classes
const ecc = new ECC(a, b, p, G, q);
const paillier = new Paillier();

class TwoPartySigning {
  constructor(...instances) {
    /** With 'combineInstancesInto' you can access all instances properties with 'this.property'*/
    combineInstancesInto(this, instances);
  }

  /**
   * Computes a hash value based on the provided inputs.
   * @param {...any} inputs - A variable number of inputs to be hashed. Each input can be a number, string, or elliptic curve point.
   * @returns {BigInt} - The resulting hash as a BigInt.
   */
  hash(...inputs) {
    const data = inputs.map((input) => input?.toString()).join("|");
    return BigInt(
      "0x" + crypto.createHash("sha256").update(data).digest("hex")
    );
  }

  /** 2 - Paillier Key Generation by P1 and x1 encryption*/
  /**
   * Paillier key generation by P1 and encryption of x1.
   * @param {BigInt} x1 - The private scalar value (secret key) of P1.
   * @returns {Object} - An object containing:
   *   - `pkPaillierP1`: Public key for Paillier encryption.
   *   - `skPaillierP1`: Private key for Paillier encryption.
   *   - `c_key`: Paillier-encrypted value of x1.
   */
  paillierEncryption(x1) {
    // One party P1 generates Paillier keys
    var p_paillier = 281062564983417584197879099904493071909n;
    var q_paillier = 266887658682941094264835878405310435687n;
    var { publicKey: pkPaillierP1, privateKey: skPaillierP1 } =
      this.generateRandomKeys(p_paillier, q_paillier);

    // P1 encrypts his secret key x1 and shares it to P2
    var c_key; // encrypt 'x1' by using paillier
    return { pkPaillierP1, skPaillierP1, c_key };
  }

  /** 3 - P2's heavy lifting: P2 calculates c3 */
  /**
   * Computes c3 using the provided inputs.
   * @param {BigInt} hashM - The hash of the message to be signed.
   * @param {Point} R - Elliptic curve point R = k1 * G.
   * @param {BigInt} k2 - The random scalar generated by P2 during signing.
   * @param {Object} pkPaillierP1 - The Paillier public key of P1.
   * @param {BigInt} c_key - Paillier-encrypted value of x1
   * @returns {Object} - An object containing:
   *   - `c3`: The computed ciphertext c3, a Paillier-encrypted value.
   */
  calculateC3(hashM, R, k2, pkPaillierP1, c_key) {
    var r;
    var rho;
    var invk2 = this.invMod(k2, this.q);

    var c1;
    var v;
    var c2;
    var c3;

    return { c3 };
  }

  /** 4 - P1 completes the signature creation */
  /**
   * Computes the final signature (r, s).
   * @param {Point} R - Elliptic curve point R = k1 * G.
   * @param {Object} skPaillierP1 - The Paillier private key of P1.
   * @param {Object} pkPaillierP1 - The Paillier public key of P1.
   * @param {BigInt} c3 - Paillier-encrypted value.
   * @param {BigInt} k1 - The random scalar generated by P1 during signing.
   * @returns {Object} - The ECDSA signature as an object containing:
   *   - `r`: The x-coordinate of R (mod q).
   *   - `s`: The computed s value.
   */
  createSignature(R, skPaillierP1, pkPaillierP1, c3, k1) {
    var r;
    var sPrime;
    var invk1 = this.invMod(k1, this.q);
    var sPrimePrime;
    var s;

    // if (s > (this.q - 1n) / 2n)
    //   throw new Error("s must be lower than (q - 1)/2");

    var signature = { r, s };
    return signature;
  }

  /** 5 - Signature verification (anyone could do it) */
  /**
   * Verifies the ECDSA signature (r, s).
   * @param {BigInt} r - The r value of the signature.
   * @param {BigInt} s - The s value of the signature.
   * @param {BigInt} hashM - The hash of the message to verify.
   * @param {Point} Q - The public key of the signer.
   * @returns {boolean} - True if the signature is valid, false otherwise.
   */
  signatureVerification(r, s, hashM, Q) {
    var s_inv;
    var u1;
    var u2;

    var P;

    return false; //P.x == r;
  }
}

var partyOne = new TwoPartySigning(ecc, paillier);
var partyTwo = new TwoPartySigning(ecc, paillier);

/** 1 - Key Share Generation: P1 and P2 come up with Q */
var x1; // P1 creates a random secret key x1
var Q1; // P1 calculates his public key Q1 = G ⋅ x1
var x2; // P2 creates a random secret key x2
var Q2; // P2 calculates his public key Q2 = G ⋅ x2

// Diffie-Hellman Exchange to find Q
var QP1; // Q = Q2 ⋅ x1
var QP2; // Q = Q1 ⋅ x2
// if (QP1.x != QP2.x || QP1.y != QP2.y)
//   throw new Error("Invalid shared Public Key");
var Q = QP1;

/** 2 - Paillier Key Generation by P1 and x1 encryption*/
var { pkPaillierP1, skPaillierP1, c_key } = partyOne.paillierEncryption(x1);

/** 3 - P2's heavy lifting: P2 calculates c3 */
var m = "Message to be signed jointly.";
var hashM = partyTwo.hash(m);

// Diffie-Hellman Exchange to find R
var k1;
var R1;
var k2;
var R2;
var QR1; // Q = Q2 ⋅ k1
var QR2; // Q = Q1 ⋅ k2
// if (QR1.x != QR2.x || QR1.y != QR2.y)
//   throw new Error("Invalid shared Public Key");
var R = QR1;

var { c3 } = partyTwo.calculateC3(hashM, R, k2, pkPaillierP1, c_key);

/** 4 - P1 completes the signature creation */
var { r, s } = partyOne.createSignature(R, skPaillierP1, pkPaillierP1, c3, k1);

/** 5 - Signature verification (anyone could do it) */
var valid = partyTwo.signatureVerification(r, s, hashM, Q);
console.log("Is the signature valid?:", valid);
