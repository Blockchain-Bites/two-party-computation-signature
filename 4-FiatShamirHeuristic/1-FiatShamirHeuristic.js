var crypto = require("crypto");
var { ECC, Point } = require("../0-EllipticCurve/EllipticCurve");

class FiatShamirHeuristic extends ECC {
  /**
   * Constructs an elliptic curve object with curve parameters.
   * @param {number} a - The parameter 'a' in the Weierstrass equation: y^2 = x^3 + ax + b.
   * @param {number} b - The parameter 'b' in the Weierstrass equation.
   * @param {number} p - The prime modulus (finite field size).
   * @param {Point} G - The generator point of the curve.
   * @param {number} q - The order of the elliptic curve (number of points in the group).
   */
  constructor(a, b, p, G, q) {
    super(a, b, p, G, q);
    /** All this properties are accessible through this.a, this.b, ... */
  }

  /**
   * Computes a hash value based on the provided inputs.
   * @param {...any} inputs - A variable number of inputs to be hashed. Each input can be a number, string, or elliptic curve point.
   * @returns {BigInt} - The resulting hash as a BigInt.
   */
  hash(...inputs) {
    const data = inputs.map((input) => input?.toString()).join("|");
    return BigInt(
      "0x" + crypto.createHash("sha256").update(data).digest("hex")
    );
  }

  /**
   * Step 2: Commit phase. Alice (the prover) generates a commitment point `t` based on a random scalar value `r`.
   * Computes `t = r * G (mod p)` where `G` is the generator point of the elliptic curve.
   * @param {BigInt} r - Random scalar selected by the prover. Must be in the range [1, q-1].
   * @returns {Point} - The commitment point `t` as an elliptic curve point.
   */
  commit(r) {}

  /**
   * Step 3: Challenge phase. Alice (the prover) generates a challenge `c` based on the Fiat-Shamir heuristic.
   * Computes `c = Hash(G, t)` where `G` is the generator point and `t` is the commitment.
   * @param {Point} G - The generator point of the elliptic curve.
   * @param {Point} t - The commitment point generated by the prover.
   * @returns {BigInt} - The challenge value `c` as a BigInt.
   */
  challenge(G, t) {}

  /**
   * Step 4: Response phase. Alice (the prover) calculates the response value `s`.
   * Computes `s = (r + c * x) % q` where `r` is the random scalar, `c` is the challenge,
   * and `x` is the prover's secret (private key).
   * @param {BigInt} r - The random scalar used during the commitment phase.
   * @param {BigInt} c - The challenge generated by the verifier.
   * @param {BigInt} x - The prover's private key (secret scalar).
   * @returns {BigInt} - The response value `s` as a BigInt.
   */
  calculateS(r, c, x) {}

  /**
   * Step 5: Verification phase. Any verifier checks the validity of the proof using `s`, `t`, `y`, and `c`.
   * Verifies that `s · G = t + c · y`, which ensures that the prover knows the discrete logarithm of `y`.
   * @param {BigInt} s - The response value computed by the prover.
   * @param {Point} t - The commitment point generated by the prover.
   * @param {Point} y - The prover's public key (calculated as `y = x * G`).
   * @param {BigInt} c - The challenge generated during the challenge phase.
   * @returns {boolean} - True if the verification is successful, otherwise false.
   */
  verify(s, t, y, c) {}
}

module.exports = { FiatShamirHeuristic, Point };
